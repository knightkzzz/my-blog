import{_ as s,c as l,o as a,ae as n}from"./chunks/framework.DbnbUhgt.js";const g=JSON.parse('{"title":"核心概念","description":"","frontmatter":{},"headers":[],"relativePath":"web/前端工程化/webpack.md","filePath":"web/前端工程化/webpack.md"}'),t={name:"web/前端工程化/webpack.md"};function e(o,i,h,p,r,k){return a(),l("div",null,i[0]||(i[0]=[n(`<h1 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h1><ul><li>entry: 项目入口文件</li><li>output 输出bundle文件路径</li><li>module webpack在构建过程中的构建对象，及被loader处理过的文件</li><li>plugin 插件</li><li>loader 文件转换器</li><li>bundle 构建完成的产物，及输出到目录的js文件</li><li>chunk 构建过程中的产物，及代码块，一个Chunk可以包含多个Module，若配置了文件分割，可能会生成多个Chunk</li><li>moduleGraph 模块依赖图，记录了模块之间的依赖关系</li></ul><hr><h1 id="构建主流程" tabindex="-1">构建主流程 <a class="header-anchor" href="#构建主流程" aria-label="Permalink to &quot;构建主流程&quot;">​</a></h1><p>本质上webpack是一个壳，里面封装了各种内置插件以及定义了各种流程，webpack只是定义了一个流水线让插件可以按流程进行工作，各个插件完成具体的功能</p><ol><li><strong>初始化</strong></li></ol><ul><li>初始化Compiler</li><li>初始化options</li><li>调用外部插件</li><li>初始化环境environment</li><li>处理入口参数</li><li>加载内部插件</li><li>初始化查找器</li><li><strong>标志初始化完毕hook --- initialize</strong></li></ul><ol start="2"><li>编译与构建</li></ol><ul><li><strong>标志进入编译阶段hook --- run</strong></li><li>准备Compilation的参数(normalModuleFactory,contextModuleFactory)</li><li>创建Compilation，标志创建完成的hook --- compilation，标志一个新的Compilation触发hook --- watchRun</li><li><strong>标志进入构建阶段hook --- make</strong></li><li>通过addEntry方法把入口添加到模块树中</li><li>根据模块类型通过normalModuleFactory或者contextModuleFactory生成Moudle对象</li><li>通过buildModule方法对模块进行构建，构建过程会调用loader对模块进行处理，将匹配到的文件转义一次，接着会调用parser对文件进行解析，生成AST，进行遍历转换，最后生成依赖关系，此过程会进行递归处理，最终完成所有模块的构建，形成ModuleGraph</li><li>标志构建完成的hook --- finishModules</li><li><strong>标志进入封存阶段的hook --- seal,封存Compilation,生成chunk图</strong></li><li><strong>标志进入优化阶段hook --- optimize,这一阶段对chunk以及Module进行优化</strong></li><li><strong>进入代码生成阶段hook --- processAssets,这一阶段会计算Hash值以及根据chunk图生成代码块</strong></li></ul><ol start="3"><li>输出</li></ol><ul><li>标志编译与构建结束hook --- afterCompile</li><li><strong>标志进入输出阶段hook --- emit,这里会循环输出每个资源</strong></li><li>标志输出资源到output目录hook --- afterEmit</li><li><strong>标志输出完成hook --- done</strong></li></ul><hr><h1 id="loader" tabindex="-1">Loader <a class="header-anchor" href="#loader" aria-label="Permalink to &quot;Loader&quot;">​</a></h1><p><strong>本质上是文件转换器，例如.vue文件、.ejs文件，自定义要处理的文件等</strong></p><ul><li>同步Loader直接返回处理过的content</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someSyncOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(content);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><ul><li>异步Loader通过async返回callback对处理过的content进行返回</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> callback </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  someAsyncOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(content, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (err) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, result, map, meta);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><ul><li>常用的Loader</li></ul><hr><h1 id="plugin" tabindex="-1">Plugin <a class="header-anchor" href="#plugin" aria-label="Permalink to &quot;Plugin&quot;">​</a></h1><p><strong>本质上是在webpack构建的各个生命周期中进行对资源的处理</strong></p><ol><li>自定义插件常用的hooks</li></ol><ul><li><strong>Compiler Hooks</strong><ol><li>emit: 在确定好文件输出内容后，将文件输出到output目录前触发。</li><li>afterEmit: 在文件输出到output目录后触发。</li><li>compilation: 当一个新compilation创建时触发，compilation对象包含了当前的模块、编译生成资源、变化的文件等信息。</li><li>watchRun: 在监听模式下，当出现一个新的Compilation时触发</li><li>done: 在完成所有编译后触发，无论成功或失败。</li></ol></li><li><strong>Compilation Hooks</strong><ol><li>optimize: 在优化步骤之前调用，可以用来分析或修改模块。</li><li>processAssets:允许插件在生成文件到output目录前添加额外的资源。</li><li>optimizeModules: 在优化模块后调用，可以用来进一步优化模块。</li><li>optimizeChunks: 在优化chunks后调用，可以用来进一步优化chunks。</li></ol></li></ul><hr><h1 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h1><p><strong>主要是从打包、构建速度与包体积两个层面进行优化</strong></p><ul><li><strong>构建速度</strong></li><li><strong>包体积</strong><ol><li><strong>TreeShaking</strong><br> 触发条件：<br><span style="margin-left:1em;">使用解构的方式导入包</span><br><span style="margin-left:1em;">要导入的包必须是ESM规范，且采用export导出</span><br><span style="margin-left:1em;">如果是单个文件的TreeShaking，在webpack中要开启production模式才能触发</span></li><li><strong>Code Splitting</strong><br></li></ol><ul><li>通过在optimization配置splitChunks进行代码分割，默认会分割node_modules中的包</li><li>分包时可以设置minSize,表示最小分割大小，当模块大于minSize时才会进行分割</li><li>分包时可以设置name,表示分包名称</li><li>分包时可以通过设置cacheGroups针对某个包进行单独分割，要注意的是cacheGroups会受到minSize的影响</li><li>举个例子你的minSize设置为300kb，分包名为common，打出的bundle为700kb，那么此时会分割成bundle.js和common.js,如果此时common.js大于300kb，那么就会针对于cacheGroups进行进一步分割，如果小于300kb，那么就不会进行分割</li></ul><ol start="3"><li><strong>压缩</strong><br></li></ol><ul><li>在optimization配置minimize中开启</li><li>在optimization.minimizer中配置压缩的插件</li></ul></li></ul><hr><h1 id="webpack-dev-server" tabindex="-1">webpack-dev-server <a class="header-anchor" href="#webpack-dev-server" aria-label="Permalink to &quot;webpack-dev-server&quot;">​</a></h1><p><strong>webpack-dev-server是webpack的扩展，用于提供一个本地服务器，并自动刷新浏览器</strong></p>`,31)]))}const c=s(t,[["render",e]]);export{g as __pageData,c as default};
