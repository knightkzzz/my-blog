import{_ as s,c as a,o as l,ae as n}from"./chunks/framework.DbnbUhgt.js";const E=JSON.parse('{"title":"核心概念","description":"","frontmatter":{},"headers":[],"relativePath":"web/前端工程化/webpack.md","filePath":"web/前端工程化/webpack.md"}'),t={name:"web/前端工程化/webpack.md"};function e(h,i,p,k,r,o){return l(),a("div",null,i[0]||(i[0]=[n(`<h1 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h1><ul><li>entry: 项目入口文件</li><li>output 输出bundle文件路径</li><li>module webpack在构建过程中的构建对象</li><li>plugin 插件</li><li>loader 文件转换器</li><li>bundle 构建完成的产物</li><li>chunk 构建过程中的产物</li></ul><hr><h1 id="构建主流程" tabindex="-1">构建主流程 <a class="header-anchor" href="#构建主流程" aria-label="Permalink to &quot;构建主流程&quot;">​</a></h1><ol><li>初始化参数</li><li>开始编译</li><li>确定入口</li><li>编译模块</li><li>完成构建</li><li>输出结果</li></ol><hr><h1 id="loader" tabindex="-1">Loader <a class="header-anchor" href="#loader" aria-label="Permalink to &quot;Loader&quot;">​</a></h1><p><strong>本质上是文件转换器，例如.vue文件、.ejs文件，自定义要处理的文件等</strong></p><ul><li>同步Loader直接返回处理过的content</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someSyncOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(content);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><ul><li>异步Loader通过async返回callback对处理过的content进行返回</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> callback </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  someAsyncOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(content, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (err) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, result, map, meta);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><ul><li>常用的Loader</li></ul><hr><h1 id="plugin" tabindex="-1">Plugin <a class="header-anchor" href="#plugin" aria-label="Permalink to &quot;Plugin&quot;">​</a></h1><p><strong>本质上是在webpack构建的各个生命周期中进行对资源的处理</strong></p><ol><li>自定义插件常用的hooks</li></ol><ul><li><strong>Compiler Hooks</strong><ol><li>emit: 在确定好文件输出内容后，将文件输出到output目录前触发。</li><li>compilation: 当一个新compilation创建时触发，compilation对象包含了当前的模块、编译生成资源、变化的文件等信息。</li><li>done: 在完成所有编译后触发，无论成功或失败。</li></ol></li><li><strong>Compilation Hooks</strong><ol><li>optimize: 在优化步骤之前调用，可以用来分析或修改模块。</li><li>processAssets:允许插件在生成文件到output目录前添加额外的资源。</li><li>optimizeModules: 在优化模块后调用，可以用来进一步优化模块。</li><li>optimizeChunks: 在优化chunks后调用，可以用来进一步优化chunks。</li></ol></li></ul><hr><h1 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h1><p><strong>主要是从打包、构建速度与包体积两个层面进行优化</strong></p><ul><li><strong>构建速度</strong></li><li><strong>包体积</strong><ol><li><strong>TreeShaking</strong><br> 触发条件：<br><span style="margin-left:1em;">使用解构的方式导入包</span><br><span style="margin-left:1em;">要导入的包必须是ESM规范，且采用export导出</span><br><span style="margin-left:1em;">如果是单个文件的TreeShaking，在webpack中要开启production模式才能触发</span></li><li><strong>Code Splitting</strong><br></li></ol><ul><li>通过在optimization配置splitChunks进行代码分割，默认会分割node_modules中的包</li><li>分包时可以设置minSize,表示最小分割大小，当模块大于minSize时才会进行分割</li><li>分包时可以设置name,表示分包名称</li><li>分包时可以通过设置cacheGroups针对某个包进行单独分割，要注意的是cacheGroups会受到minSize的影响</li><li>举个例子你的minSize设置为300kb，分包名为common，打出的bundle为700kb，那么此时会分割成bundle.js和common.js,如果此时common.js大于300kb，那么就会针对于cacheGroups进行进一步分割，如果小于300kb，那么就不会进行分割</li></ul><ol start="3"><li><strong>压缩</strong><br></li></ol><ul><li>在optimization配置minimize中开启</li><li>在optimization.minimizer中配置压缩的插件</li></ul></li></ul><hr><h1 id="webpack-dev-server" tabindex="-1">webpack-dev-server <a class="header-anchor" href="#webpack-dev-server" aria-label="Permalink to &quot;webpack-dev-server&quot;">​</a></h1><p><strong>webpack-dev-server是webpack的扩展，用于提供一个本地服务器，并自动刷新浏览器</strong></p>`,25)]))}const c=s(t,[["render",e]]);export{E as __pageData,c as default};
